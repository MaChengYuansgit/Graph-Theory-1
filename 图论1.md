  **图论〔Graph Theory〕**
是一个古老的但又十分活跃的数学学科，也是一门很有实用价值的学科，它在自然科学、社会科学等各领域均有很多应用。近年来它受计算机科学蓬勃发展的刺激，发展极其迅速。应用范围不断拓广，已渗透到诸如语言学、逻辑学、物理学、化学、电讯工程、计算机科学以及数学的其它分支中。
![](https://files.mdnice.com/user/22059/7d144674-c00e-4608-a698-25650434d0d1.jpeg)
  它以图为研究对象。图论中的图是由若干给定的点及连接两点的线所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系，用点代表事物，用连接两点的线表示相应两个事物间具有这种关系。

  1736年是图论的历史元年。第一篇图论论文是瑞士数学家欧拉于 1736 年发表的“哥尼斯堡的七座桥”，这也是著名的哥尼斯堡七桥问题。

  在哥尼斯堡有七座桥将普莱格尔河中的两个岛及岛与河岸联结起来，问题是要从这四块陆地中的任何一块开始通过每一座桥正好一次，再回到起点。
  ![哥尼斯堡七桥问题](https://files.mdnice.com/user/22059/afc58fe2-5376-4a01-945a-b26ffdbb6f31.png)
  这个问题似乎不难，谁都乐意用这个问题来测试一下自己的智力。可是，谁也没有找到一条这样的路线。这个问题极大的刺激了德意志人的好奇心，许多人热衷于解决这个问题，然而始终未能成功。“七桥问题”难住了哥尼斯堡城的所有居民。哥尼斯堡城也因“七桥问题” 而出了名。这就是数学史上著名的七桥问题。

  欧拉为了解决这个问题，采用了建立数学模型的方法。他将上述四块陆地与七座桥间的关系用一个抽象图形来描述：每一块陆地用一个点来代替，将每一座桥用连接相应两点的一条线来代替，从而得到一个有四个“点”，七条“线”的“图”。问题成为从任一点出发一笔画出七条线再回到起点。欧拉考察了一般一笔画的结构特点，给出了一笔画的一个判定法则：这个图是连通的，且每个点都与偶数线相关联，将这个判定法则应用于七桥问题，得到了“不可能走通”的结果，不但彻底解决了这个问题，而且开创了图论研究的先河。

  从19世纪中叶开始，图论进入第二个发展阶段。这一时期图论问题大量出现，诸如关于地图染色的四色问题、由“周游世界”游戏发展起来的哈密顿(W.Hamilton)问题等。

   图与网络是运筹学（Operations Research）中的一个经典和重要的分支，所研究的问题涉及经济管理、工业工程、交通运输、计算机科学与信息技术、通讯与网络技术等诸多领域。今年笔者在参加学校举办的物流设计大赛的时候，发现长株潭物流枢纽之间的运输问题可以运用图论知识解决，于是有感而发写下这篇拙作，分享一些关于图论的知识。

## 图的基本概念

下面首先简要介绍图论的一些基本概念。


定义：一个图$G$是指一个二元组$(V(G),E(G))$,其中:
$$V(G)=\{v_1,v_2,...,v_n\},\quad  V(G)为顶点集,v_i为G中顶点$$
$$E(G)=\{e_1,e_2,...,e_m\},\quad  E(G)为边集,e_i为G中的边$$
一个图称为有限图，如果它的顶点集和边集都有限。图G的顶点数用符号$|V|或v(G) $表示，边数用$|E|或ε(G)$表示。

只有一个顶点的图称为平凡图，其他的所有图都称为非平凡图。

端点重合为一点的边称为环(loop)。

![](https://files.mdnice.com/user/22059/e98c7fba-b836-44d1-9304-d47e0244b3d9.png =60%x)

一个图称为简单图(simple graph)，如果它既没有环也没有两条边连接同一对顶点。

一个有向图（directed graph 或 digraph）G 是由一个非空有限集合V 和V 中某些元素的有序对集合 A 构成的二元组，记为$G = (V, A)$。
其中$$V=\{v_1,v_2,...,v_n \}$$
称为图G的顶点集或节点集，V 中的每一个元素 $v_i(i=1,2,...,n)$称为该图的一个顶点或节点；$$A = \{a_1,a_2,...,a_m\}$$ 称为图G的弧集（arc set），A 中的每一个元素$a_k $(即V中某两个元素$v_i,v_j$的有序对)记为$a_k=(v_i,v_j) $ 或$v_iv_j(k=1,2,...,n)$，被称为该图的一条从 $v_i$到$v_j$ 的弧（arc）,并称弧$a_k $为 $v_i$ 的出弧（outgoing arc），为 $v_j$ 的入弧（incoming arc）。

任意两顶点都相邻的简单图,称为完全图(complete graph)。n 个顶点的完全图记为$ K_n$ 。

图H叫做图 G 的子图（subgraph），记作$H⊂G$，如果$V(H)⊂V(G),E(H) ⊂ E(G)$。若H是G的子图，则G称为H的母图。

G 的支撑子图（spanning subgraph，又成生成子图）是指满足$V(H)=V(G)$的子图 H 。

若图$G=(V(G),E(G))$的每一条边e都赋以一个实数w(e)，称w(e)为边e的权，G 连同边上的权称为赋权图。

设$v∈V(G)$ ，G中与v关联的边数（每个环算作两条边）称为v的度(degree)，记作d(v)。若d(v)是奇数，称v是奇顶点(odd point)；d(v)是偶数，称v是偶顶点(even point)。关于顶点的度，我们有如下结论：

(1)$$\sum_{v∈V}d(v)=2ε$$

(2)任何一个图中奇顶点的个数都是偶数。

## 图的矩阵表示

这里我们介绍计算机上用来描述图与网络的 5 种常用表示方法：邻接矩阵表示法、关联矩阵表示法、弧表表示法和邻接表表示法。

### 邻接矩阵表示法

邻接矩阵表示法是将图以邻接矩阵（adjacency matrix）的形式存储在计算机中。图$G $的邻接矩阵是如下定义的：

对无向图G，其邻接矩阵为：$$A=(a_{ij})_{v×v}$$
其中
$$ a_{ij}=\left\{
\begin{matrix}
1 \quad 若v_i与v_j相邻\\
0 \quad 若v_i与v_j不相邻
\end{matrix}
\right.
$$




![](https://files.mdnice.com/user/22059/7fb2375b-1193-4cb1-89e2-3bed5e8e2a6e.png)

对有向图G=(V,E)，其邻接矩阵为：$$A=(a_{ij})_{v×v}$$
其中
$$ a_{ij}=\left\{
\begin{matrix}
1 \quad 若(v_i,v_j)∈E\\
0 \quad 若(v_i,v_j)∉E
\end{matrix}
\right.
$$

![](https://files.mdnice.com/user/22059/fc049e2b-857d-4e92-a930-7cd65f629c5b.png)


也就是说，如果两节点之间有一条弧，则邻接矩阵中对应的元素为 1；否则为 0。
可以看出，这种表示法非常简单、直接。

同样，对于网络中的权，也可以用类似邻接矩阵的n × n 矩阵表示。只是此时一条
弧所对应的元素不再是 1，而是相应的权而已。如果网络中每条弧赋有多种权，则可以用多个矩阵表示这些权。

![](https://files.mdnice.com/user/22059/edf79e21-ebcd-4b19-91fd-b73e7dab48e2.png)


### 关联矩阵表示法

关联矩阵表示法是将图以关联矩阵（incidence matrix）的形式存储在计算机中．图
G = (V, A)的关联矩阵$M=(m_{ij})_{v×ε} $ 是如下定义的：

其中：
$$m_{ij}=\left\{
\begin{matrix}
1,\quad 若v_i是e_j的尾\\
-1,\quad 若v_i是e_j的头 \\
0, \quad 若v_i不是e_j的头与尾
\end{matrix}
\right.
$$

![](https://files.mdnice.com/user/22059/8277ef28-6db2-483a-91fb-5c615b8601f0.png)

### 弧表表示法

弧表表示法将图以弧表（arc list）的形式存储在计算机中。所谓图的弧表，也就是
图的弧集合中的所有有序对。弧表表示法直接列出所有弧的起点和终点，共需2m个存储单元，因此当网络比较稀疏时比较方便。此外，对于网络图中每条弧上的权，也要对
应地用额外的存储单元表示。
![](https://files.mdnice.com/user/22059/d94b4c9f-94db-4f23-a50f-818e616e34ff.png =50%x)

![](https://files.mdnice.com/user/22059/0b95f28b-72af-4c3e-898d-8845721dc891.png)

### 邻接表表示法

邻接表表示法将图以邻接表（adjacency lists）的形式存储在计算机中。所谓图的邻接表，也就是图的所有节点的邻接表的集合；而对每个节点，它的邻接表就是它的所有出弧。邻接表表示法就是对图的每个节点，用一个单向链表列出从该节点出发的所有弧，链表中每个单元对应于一条出弧。为了记录弧上的权，链表中每个单元除列出弧的另一个端点外，还可以包含弧上的权等作为数据域。图的整个邻接表可以用一个指针数组表示。

![](https://files.mdnice.com/user/22059/c9b30d90-3b91-423c-975f-e690fa6a785c.png =50%x)

![](https://files.mdnice.com/user/22059/09d0ecc8-b8ac-4d71-bec4-0c37f69aed62.png)

这是一个 5 维指针数组，每一维（上面表示法中的每一行）对应于一个节点的邻接表，如第 1 行对应于第 1 个节点的邻接表（即第 1 个节点的所有出弧）。每个指针单元的第 1 个数据域表示弧的另一个端点（弧的头），后面的数据域表示对应弧上的权。



### 轨与连通

$$ W=v_0e_1v_1e_2...e_kv_k $$
,其中$e_i∈E(G),1≤i≤k$,$v_j∈V(G),0≤j≤k$,$e_i$与$v_iv_{i-1}$关联，称W是图G的一条道路(walk),k为路长，顶点$v_0$和$v_k$分别称为W的起点和终点，而$v_1,v_2,...,v_{k-1}$称为它的内部顶点。

若道路W的边互不相同，则W称为迹(trail)。若道路W的顶点互不相同，则W称为轨(path)。

如果它有正的长且起点和终点相同,称一条道路是闭的。起点和终点重合的轨叫做圈(cycle)。

若图G的两个顶点$u,v$间存在道路，则称$u和v$连通(connected)。$u,v$间的最短轨的长叫做$u,v$间的距离。记作$d(u,v)$若图G的任二顶点均连通，则称G是连通图。

显然我们有以下结论:

(1)图P为一条轨的充要条件是：P连通，且有两个1度的顶点，其余顶点的度数都是2。</br>

(2)图Q为一个圈的充要条件是：Q是所有顶点度数都为2的连通图。
</br>

## 应用

### 最短路径问题

最短路问题是图论应用的基本问题，很多实际问题，如线路的布设、运输安排、运输网络最小费用流等问题，都可通过建立最短路问题模型来求解。

#### 两个指定顶点间的最短路径

问题如下：给出了一个连接若干个城市的高速公路网络，在这个网络的两个指定城市间，找一条最短路线。

以各城市为图G的顶点，两城市间的直通公路为图G相应两顶点间的边，得图G。
对G的每一边e，赋以一个实数$w(e)$为这两城市直通高速公路的长度，称为e的权，得到赋权图G。G的子图的权是指子图的各边的权和。

问题就是求赋权图G中指定的两个顶点$u_0,v_0$间的具最小权的轨。这条轨叫做 $u_0,v_0$间的最短路，它的权叫做$u_0,v_0$间的距离，亦记作$d(u_0,v_0)$。

求最短路已有成熟的算法：迪克斯特拉（Dijkstra）算法，其基本思想是按距$u_0$从近到远为顺序，依次求得$u_0$到G的各顶点的最短路和距离，直至$v_0$（或直至G的所有顶点），算法结束。为避免重复并保留每一步的计算信息，采用了标号算法。

下面是该算法。

$(i) l(u_0)=0,对于v\neq u_0,l(v)=\infty,$$S_0=\left\{u_0\right \},i=0$.

$(ii)对每一个v \in \overline{S_{i}}\left(\overline{S}_{i}=V \setminus  S_{i}\right)$,用$\min \left\{l(v), l\left(u_{i}\right)+w\left(u_{i}, v\right)\right\}$代替$l(v)$。计算$\min _{v \in S_{i}}\{l(v)\}$,把达到这个最小值的一个顶点记为 $u_{i+1}$ ，令$S_{i+1}=S_{i} \cup\left\{u_{i+1}\right\}$。

$(iii)若i=\left | V \right |-1 $,则停止。若$i<\left | V \right |-1$,$则用i+1代替i，转(ii)$。

算法结束时，从$u_0$到各顶点$v的距离由v的最后一次的标号l(v)给出$。在$v$ 进入$S_i之前的标号l(v)叫T$标号，$v进入S_i$时的标号$l(v)$叫$P$标号。算法就是不断修改各顶点的$T标号，直至获得P$标号。若在算法运行过程中，将每一顶点获得$P$标号所由来的边在图上标明，则算法结束时，$u_0$至各项点的最短路也在图上标示出来了。

下面解决一个关于高速公路导航的实际问题：

在湖南省高速公路网络中，有长沙、株洲、湘潭、益阳、衡阳、娄底、邵阳、岳阳、常德、郴州、永州、张家界、怀化等城市，下面对湖南高速公路网络进行分析，请设计长沙到其他城市的最短高速公路路线图。（从一个城市到另一个城市的高速公路直接路程(来源于百度地图时间最短方案)记在下述矩阵的$(i,j)$位置上）

![](https://files.mdnice.com/user/22059/76ed7956-78b3-43b1-8a32-853ae32f64b5.jpeg)


$$\left[\begin{array}{ccccccccccccc}
0 & 71.9 & 54.6 & 82.2 & 191.2 & 132.3&231.2& 165.5&172.4&371.1&317.6&324.0&385.3\\
71.9 & 0 & 28.8 & 143.0 & 142 & 144&218&199&237&263&274&288&293 \\
54.6 & 28.8 & 0 & 126 & 147 & 119&201&196&220&268&265&369&376 \\
82.2 & 143 & 126 & 0 & 239 & 123&209&193&102&394&322&251&326 \\
191.2 & 142 & 147 & 239 & 0 & 133&142&321&326&189&136&475&344 \\
132.3 & 144 & 119 & 123 & 133 & 0&97&284&193&306&211&341&264\\
231.2 & 218 & 201 & 209 & 142 & 97&0& 365&253&314&123&402&217\\
165.5 & 199& 196& 193& 321& 284&365& 0&185&445&445&324&472\\
172.4 & 237 & 220 & 102 & 326 & 193&253& 185&0&237&357&158&298\\
371.1 & 263 & 268& 394& 189& 306&314& 445&237&0&230&635&518\\
317.6 & 274 & 265& 322& 136& 211&123& 445&357&230&0&507&311\\
324.0 & 288 & 369& 251& 475& 341&402& 324&158&635&507&0&258\\
385.3 & 293 & 376& 326 & 344& 264&217& 472&298&518&311&258&0
\end{array}\right]
$$

用矩阵$a_{n×n}（n为顶点个数）$存放各边权的邻接矩阵，行向量$pb、index_1$$ 、index_2 、d$分别用来存放$P$标号信息、标号顶点顺序、标号顶点索引、最短通路的值。其中分量
$$
pb(i)=\left\{\begin{matrix}
 1 &当第i顶点已标号 \\
 0 &当第i顶点未标号
\end{matrix}\right.
$$
$index_2(i)存放始点到第i点最短通路中第i$顶点前一顶点的序号；
$d(i)存放由始点到第i点最短通路的值。$

求一个城市到另一个城市的最短路径的 Matlab 程序如下：


```
function [mydistance,mypath]=mydijkstra(a,sb,db);
% 输入：a—邻接矩阵，a（i，j)是指i到j之间的距离，可以是有向的
% sb—起点的标号, db—终点的标号
% 输出：mydistance—最短路的距离, mypath—最短路的路径
n=size(a,1); visited(1:n) = 0;
distance(1:n) = inf; distance(sb) = 0; %起点到各顶点距离的初始化
visited(sb)=1; u=sb;  %u为最新的P标号顶点
parent(1:n) = 0; %前驱顶点的初始化
for i = 1: n-1
     id=find(visited==0); %查找未标号的顶点
     for v = id           
         if  a(u, v) + distance(u) < distance(v)
             distance(v) = distance(u) + a(u, v);  %修改标号值 
             parent(v) = u;                                    
         end            
     end
     temp=distance;
     temp(visited==1)=inf;  %已标号点的距离换成无穷
     [t, u] = min(temp);  %找标号值最小的顶点 
     visited(u) = 1;       %标记已经标号的顶点
 end
mypath = [];
if parent(db) ~= 0   %如果存在路!
    t = db; mypath = [db];
    while t ~= sb
        p = parent(t);
        mypath = [p mypath];
        t = p;      
    end
end
mydistance = distance(db);
```

我们还可以通过数学表达式来解决这个问题：
假设有向图有$n$个顶点，现需要求从顶点1到顶点$n$的最短路。设$W=(w_{ij})_{n×n}$为赋权邻接矩阵，其分量为
$$
w_{i j}=\left\{\begin{array}{ll}
w\left(v_{i} v_{j}\right), & v_{i} v_{j} \in E \\
\infty, & \text { 其它 }
\end{array}\right.
$$

决策变量为$x_{ij}$ ，当$x_{ij}=1$，说明弧$v_iv_j$位于顶点1至顶点$n$ 的路上；否则 $x_{ij}=0$。其数学规划表达式为
$$
\begin{array}{c}
\min \sum_{v_{i} v_j \in E} w_{i j} x_{i j} \\
\text { s.t. } \quad \sum_{j=1 \atop  v_jv_i \in E}^{n} x_{i j}-\sum_{j=1 \atop  v_jv_i \in E}^{n} x_{j i}=\left\{\begin{array}{ll}
1, & i=1 \\
-1, & i=n \\
0, & i \neq 1, n
\end{array}\right. \\
x_{i j}=0 \text { 或 } 1
\end{array}
$$

求一个城市到另一个城市的最短路径的Lingo程序如下：
```
model:
sets:
cities/1..13/;
roads(cities,cities):a,x;
endsets
data:
w=0;
enddata
calc:
a(1,2)=71.9;a(1,3)=54.6;a(1,4)=82.2;a(1,5)=191.2;a(1,6)=132.3;a(1,7)=231.2;a(1,8)=165.5;a(1,9)=172.4;a(1,10)=371.1;a(1,11)=317.6;a(1,12)=324;a(1,13)=385.3;
a(2,3)=28.8;a(2,4)=143;a(2,5)=142;a(2,6)=144;a(2,7)=218;a(2,8)=199;
a(2,9)=237;a(2,10)=263;a(2,11)=274;a(2,12)=288;a(2,13)=293;
a(3,4)=126;a(3,5)=147;a(3,6)=119;a(3,7)=201;a(3,8)=196;a(3,9)=220;
a(3,10)=268;a(3,11)=265;a(3,12)=359;a(3,13)=376;
a(4,5)=239;a(4,6)=123;a(4,7)=209;a(4,8)=193;a(4,9)=102;
a(4,10)=394;a(4,11)=322;a(4,12)=251;a(4,13)=326;
a(5,6)=133;a(5,7)=142;a(5,8)=321;a(5,9)=326;a(5,10)=189;
a(5,11)=136;a(5,12)=475;a(5,13)=344;
a(6,7)=97;a(6,8)=284;a(6,9)=193;a(6,10)=306;a(6,11)=211;
a(6,12)=341;a(6,13)=264;
a(7,8)=365;a(7,9)=253;a(7,10)=314;a(7,11)=123;a(7,12)=402;a(7,13)=217;
a(8,9)=185;a(8,10)=445;a(8,11)=445;a(8,12)=324;a(8,13)=472;
a(9,10)=237;a(9,11)=357;a(9,12)=158;a(9,13)=298;
a(10,11)=230;a(10,12)=635;a(10,13)=518;
a(11,12)=507;a(11,13)=311;
a(12,13)=258;

@for(roads(i,j):a(i,j)=a(i,j)+a(j,i));
@for(roads(i,j):a(i,j)=@if(a(i,j) #eq# 0, 1000,a(i,j)));
endcalc
n=@size(cities);  !城市的个数;
min=@sum(roads:a*x);
@for(cities(i)|i #ne#1 #and# i #ne# n:@sum(cities(j):x(i,j))=@sum(cities(j):x(j,i)));
@sum(cities(j):x(1,j))=1;
@sum(cities(j):x(j,1))=0; !不能回到顶点1;
@sum(cities(j):x(j,n))=1;
@for(roads:@bin(x));
       end
```

计算赋权图中各对顶点之间最短路径，显然可以调用 Dijkstra 算法。具体方法是：每次以不同的顶点作为起点，用 Dijkstra算法求出从该起点到其余顶点的最短路径，反复执行n−1次这样的操作，就可得到从每一个顶点到其它顶点的最短路径。这种算法的时间复杂度为$O(n^3)$。第二种解决这一问题的方法是由 Floyd R W提出的算法，称之为Floyd算法。

Floyd算法:

假设图G权的邻接矩阵为$A_0$，
$$
A_{0}=\left[\begin{array}{cccc}
a_{11} & a_{12} & \cdots & a_{1 n} \\
a_{21} & a_{22} & \cdots & a_{2 n} \\
\vdots & \vdots & \cdots & \vdots \\
a_{n 1} & a_{n 2} & \cdots & a_{n n}
\end{array}\right]
$$
来存放各边长度，其中：
$$
\begin{array}{ll}
a_{i i}=0 & i=1,2, \cdots, n ; \\
a_{i j}=\infty & i, j \text { 之间没有边, 在程序中以各边都不可能达到的充分大的数代替; } \\
a_{i j}=w_{i j} & w_{i j} \text { 是 } i, j \text { 之间边的长度, } i, j=1,2, \cdots, n 。
\end{array}
$$
对于无向图，$A_0$ 是对称矩阵，$a_{ij}= a_{ji}$。
Floyd 算法的基本思想是：递推产生一个矩阵序列$A_0,A_1,...,A_k,...,A_n$，其中$A_k(i,j)$表示从顶点$v_i$到顶点$v_j$的路径上所经过的顶点序号不大于k的最短路径长度。

计算时用迭代公式：
$$
A_{k}(i, j)=\min \left(A_{k-1}(i, j), A_{k-1}(i, k)+A_{k-1}(k, j)\right)
$$
$k是迭代次数,i,j,k = 1,2,...,n$。

最后，当$k = n$时,$A_n$即是各顶点之间的最短通路值。

我们编写的求起点 sb 到终点 db 通用的 Floyd 算法程序如下：

MATLAB
```
function [dist,mypath]=myfloyd(a,sb,db);
% 输入：a—邻接矩阵，元素(aij)是顶点i到j之间的直达距离，可以是有向的
% sb—起点的标号；db—终点的标号
% 输出：dist—最短路的距离；% mypath—最短路的路径
n=size(a,1); path=zeros(n);
for k=1:n
    for i=1:n
        for j=1:n
            if a(i,j)>a(i,k)+a(k,j)
                a(i,j)=a(i,k)+a(k,j);
                path(i,j)=k;
            end
        end
    end
end
dist=a(sb,db);
parent=path(sb,:); %从起点sb到终点db的最短路上各顶点的前驱顶点
parent(parent==0)=sb; %path中的分量为0，表示该顶点的前驱是起点
mypath=db; t=db;
while t~=sb
        p=parent(t); mypath=[p,mypath];
        t=p;
end
```
lINGO

```
model:
sets:
nodes/c1..c13/;
link(nodes,nodes):a,path;  !path标志最短路径上走过的顶点;
endsets
data:
path=0;
a=0;
@text(mydata1.txt)=@writefor(nodes(i):@writefor(nodes(j):
@format(a(i,j),' 10.0f')),@newline(1));
@text(mydata1.txt)=@write(@newline(1));
@text(mydata1.txt)=@writefor(nodes(i):@writefor(nodes(j):
@format(path(i,j),' 10.0f')),@newline(1));
enddata
calc:
a(1,2)=71.9;a(1,3)=54.6;a(1,4)=82.2;a(1,5)=191.2;a(1,6)=132.3;a(1,7)=231.2;
a(1,8)=165.5;a(1,9)=172.4;a(1,10)=371.1;a(1,11)=317.6;a(1,12)=324;a(1,13)=385.3;
a(2,3)=28.8;a(2,4)=143;a(2,5)=142;a(2,6)=144;a(2,7)=218;a(2,8)=199;
a(2,9)=237;a(2,10)=263;a(2,11)=274;a(2,12)=288;a(2,13)=293;
a(3,4)=126;a(3,5)=147;a(3,6)=119;a(3,7)=201;a(3,8)=196;a(3,9)=220;
a(3,10)=268;a(3,11)=265;a(3,12)=359;a(3,13)=376;
a(4,5)=239;a(4,6)=123;a(4,7)=209;a(4,8)=193;a(4,9)=102;
a(4,10)=394;a(4,11)=322;a(4,12)=251;a(4,13)=326;
a(5,6)=133;a(5,7)=142;a(5,8)=321;a(5,9)=326;a(5,10)=189;
a(5,11)=136;a(5,12)=475;a(5,13)=344;
a(6,7)=97;a(6,8)=284;a(6,9)=193;a(6,10)=306;a(6,11)=211;
a(6,12)=341;a(6,13)=264;
a(7,8)=365;a(7,9)=253;a(7,10)=314;a(7,11)=123;a(7,12)=402;a(7,13)=217;
a(8,9)=185;a(8,10)=445;a(8,11)=445;a(8,12)=324;a(8,13)=472;
a(9,10)=237;a(9,11)=357;a(9,12)=158;a(9,13)=298;
a(10,11)=230;a(10,12)=635;a(10,13)=518;
a(11,12)=507;a(11,13)=311;
a(12,13)=258;

@for(link(i,j):a(i,j)=a(i,j)+a(j,i));
@for(link(i,j) |i#ne#j:a(i,j)=@if(a(i,j)#eq#0,10000,a(i,j)));
@for(nodes(k):@for(nodes(i):@for(nodes(j):
tm=@smin(a(i,j),a(i,k)+a(k,j));
path(i,j)=@if(a(i,j)#gt# tm,k,path(i,j));a(i,j)=tm))); 
endcalc
end
```

由运行结果我们可以看出百度地图的导航还是比较准确的，在我们所得到的最短路径中基本均为从一城市到另一城市的直接路程。







